pub fn func() {
   print( "hoge" );
}
pub enum Foo {
   Val1,
   Val2,
}
pub alge Bar {
   Val1,
   Val2,
}
pub interface IF {
   pub fn func(val:Foo);
}
pub proto class Hoge extend (Mapping, IF);
pub class Hoge extend (Mapping, IF) {
   pub let mut val:int{pub,pub};
   pub fn __init() {
      self.val = 0;
   }
   pub fn func(val:Foo);
   pub static fn sub(val:Bar) {
      match val {
         case .Val1 {
         }
         case .Val2 {
         }
      }
   }
}
pub fn Hoge.func(val:Foo) {
   _switch val {
      case .Val1 {
      }
      case .Val2 {
      }
   }
}
pub class HogeHoge extend Hoge {
   pub override fn func( val:Foo ) {
      super( val );
   }
}
class HogeHogeHoge extend HogeHoge {
   pub fn __init() {
      super();
   }
   pub override fn func( val:Foo ) {
      super( val );
   }
}
class HogeHogeHogeHoge extend HogeHogeHoge {
   pub fn __init() {
      super();
   }
}
pub let Val = 1;
pub abstract class Sub {
   pub abstract fn get_val() : int;
   pub abstract fn set_val(val:int) mut;
}
pub class SubSub extend Sub {
   let mut val:int{pub,pub};
}
pub macro _Hoge() {
   {
      let test = `{ print("hoge"); };
   }
   ,,test;
}
pub macro _Hoge2( test:stat ) {
   ,,test;
}
pub alias FooBar = Hoge;
pub form Form();
