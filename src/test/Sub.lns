pub fn func() {
   print( "hoge" );
}
pub enum Foo {
   Val1,
   Val2,
}
pub alge Bar {
   Val1,
   Val2,
}
pub interface IF {
   pub fn func(val:Foo);
}
pub proto class Hoge extend (Mapping, IF);
pub class Hoge extend (Mapping, IF) {
   let mut val:int{pub,pub};
   pub fn __init() {
      self.val = 0;
   }
   pub fn func(val:Foo);
   pub static fn sub(val:Bar) {
      match val {
         case .Val1 {
         }
         case .Val2 {
         }
      }
   }
}
pub fn Hoge.func(val:Foo) {
   _switch val {
      case .Val1 {
      }
      case .Val2 {
      }
   }
}
pub class HogeHoge extend Hoge {
   pub override fn func( val:Foo ) {
      super( val );
   }
}
class HogeHogeHoge extend HogeHoge {
   pub fn __init() {
      super();
   }
   pub override fn func( val:Foo ) {
      super( val );
   }
}
class HogeHogeHogeHoge extend HogeHogeHoge {
   pub fn __init() {
      super();
   }
}
pub let Val = 1;

